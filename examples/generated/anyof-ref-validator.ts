// Generated by @speria-jp/json-schema-validator-gen
// https://github.com/speria-jp/json-schema-validator-gen
// Do not edit manually
// ============================================================================
// Validation Types (auto-generated)
// ============================================================================

type ValidationResult<T> =
  | { success: true; data: T }
  | { success: false; issues: ValidationIssue[] };

interface ValidationIssue {
  code: ValidationIssueCode;
  path: (string | number)[];
  message: string;
  expected: string;
  received: string;
}

type ValidationIssueCode =
  | "invalid_type"
  | "invalid_value"
  | "too_small"
  | "too_big"
  | "invalid_string"
  | "not_integer"
  | "not_unique"
  | "unrecognized_key"
  | "missing_key";

interface ValidationOptions {
  abortEarly?: boolean;
}

// ============================================================================
// Validation Helpers (auto-generated)
// ============================================================================

function _getType(value: unknown): string {
  if (value === null) return "null";
  if (Array.isArray(value)) return "array";
  return typeof value;
}

function _invalidType(issues: ValidationIssue[], path: (string | number)[], expected: string, value: unknown): void {
  const received = _getType(value);
  issues.push({ code: "invalid_type", path, message: `Expected ${expected}, received ${received}`, expected, received });
}

function _missingKey(issues: ValidationIssue[], path: (string | number)[], key: string): void {
  const expected = `object with required property "${key}"`;
  const received = `object without property "${key}"`;
  issues.push({ code: "missing_key", path, message: `Expected ${expected}, received ${received}`, expected, received });
}

function _tooSmall(issues: ValidationIssue[], path: (string | number)[], expected: string, received: string): void {
  issues.push({ code: "too_small", path, message: `Expected ${expected}, received ${received}`, expected, received });
}

function _tooBig(issues: ValidationIssue[], path: (string | number)[], expected: string, received: string): void {
  issues.push({ code: "too_big", path, message: `Expected ${expected}, received ${received}`, expected, received });
}

function _invalidString(issues: ValidationIssue[], path: (string | number)[], expected: string, received: string): void {
  issues.push({ code: "invalid_string", path, message: `Expected ${expected}, received ${received}`, expected, received });
}

function _invalidValue(issues: ValidationIssue[], path: (string | number)[], expected: string, received: string): void {
  issues.push({ code: "invalid_value", path, message: `Expected ${expected}, received ${received}`, expected, received });
}

function _notInteger(issues: ValidationIssue[], path: (string | number)[], value: number): void {
  issues.push({ code: "not_integer", path, message: `Expected integer, received ${value}`, expected: "integer", received: String(value) });
}

function _notUnique(issues: ValidationIssue[], path: (string | number)[]): void {
  issues.push({ code: "not_unique", path, message: "Expected array with unique items, received array with duplicate items", expected: "array with unique items", received: "array with duplicate items" });
}

function _unrecognizedKey(issues: ValidationIssue[], path: (string | number)[], expected: string, key: string): void {
  issues.push({ code: "unrecognized_key", path, message: `Expected ${expected}, received ${key}`, expected, received: key });
}


export type Container = {
    id: string;
    items: (TextItem | ImageItem | LinkItem)[];
};


type TextItem = {
    type: "text";
    content: string;
};


type ImageItem = {
    type: "image";
    url: string;
    alt?: string;
};


type LinkItem = {
    type: "link";
    href: string;
    label: string;
};


export type NestedAnyOf = {
    value: {
        kind: "simple";
        data: string;
    } | {
        kind: "complex";
        nested: TextItem;
    };
};


export function validateContainer(value: unknown, options?: ValidationOptions): ValidationResult<Container> {
    const issues: ValidationIssue[] = [];
    const abortEarly = options?.abortEarly ?? false;
    if (!(typeof value === "object" && value !== null && !Array.isArray(value))) {
        _invalidType(issues, [], "object", value);
        if (abortEarly)
            return { success: false, issues };
    }
    else {
        if (!("id" in value)) {
            _missingKey(issues, [], "id");
            if (abortEarly)
                return { success: false, issues };
        }
        if (!("items" in value)) {
            _missingKey(issues, [], "items");
            if (abortEarly)
                return { success: false, issues };
        }
        if ("id" in value) {
            if (!(typeof value.id === "string")) {
                _invalidType(issues, ["id"], "string", value.id);
                if (abortEarly)
                    return { success: false, issues };
            }
        }
        if ("items" in value) {
            if (!Array.isArray(value.items)) {
                _invalidType(issues, ["items"], "array", value.items);
                if (abortEarly)
                    return { success: false, issues };
            }
            else {
                for (let i1 = 0; i1 < value.items.length; i1++) {
                    let _anyOfMatched2 = false;
                    if (!_anyOfMatched2 && (() => {
                        const _tempIssues: ValidationIssue[] = [];
                        const _refResult3 = validateTextItem(value.items[i1], options);
                        if (!_refResult3.success) {
                            for (const _issue4 of _refResult3.issues) {
                                _tempIssues.push({ ..._issue4, path: [...["items", i1], ..._issue4.path] });
                            }
                            if (abortEarly)
                                return { success: false, _tempIssues };
                        }
                        return _tempIssues.length === 0;
                    })()) {
                        _anyOfMatched2 = true;
                    }
                    if (!_anyOfMatched2 && (() => {
                        const _tempIssues: ValidationIssue[] = [];
                        const _refResult5 = validateImageItem(value.items[i1], options);
                        if (!_refResult5.success) {
                            for (const _issue6 of _refResult5.issues) {
                                _tempIssues.push({ ..._issue6, path: [...["items", i1], ..._issue6.path] });
                            }
                            if (abortEarly)
                                return { success: false, _tempIssues };
                        }
                        return _tempIssues.length === 0;
                    })()) {
                        _anyOfMatched2 = true;
                    }
                    if (!_anyOfMatched2 && (() => {
                        const _tempIssues: ValidationIssue[] = [];
                        const _refResult7 = validateLinkItem(value.items[i1], options);
                        if (!_refResult7.success) {
                            for (const _issue8 of _refResult7.issues) {
                                _tempIssues.push({ ..._issue8, path: [...["items", i1], ..._issue8.path] });
                            }
                            if (abortEarly)
                                return { success: false, _tempIssues };
                        }
                        return _tempIssues.length === 0;
                    })()) {
                        _anyOfMatched2 = true;
                    }
                    if (!_anyOfMatched2) {
                        issues.push({ code: "invalid_type", path: ["items", i1], message: `Expected ${"value matching at least one schema"}, received ${"value matching no schemas"}`, expected: "value matching at least one schema", received: "value matching no schemas" });
                        if (abortEarly)
                            return { success: false, issues };
                    }
                }
            }
        }
        for (const key9 in value) {
            if (!["id", "items"].includes(key9)) {
                _unrecognizedKey(issues, [key9], `one of known properties (${["id", "items"].join(", ")})`, key9);
                if (abortEarly)
                    return { success: false, issues };
            }
        }
    }
    if (issues.length > 0) {
        return { success: false, issues };
    }
    return { success: true, data: value as Container };
}
export function unsafeValidateContainer(value: unknown): Container {
    const result = validateContainer(value, { abortEarly: true });
    if (!result.success) {
        throw new Error("Validation failed: value is not Container");
    }
    return result.data;
}


function validateTextItem(value: unknown, options?: ValidationOptions): ValidationResult<TextItem> {
    const issues: ValidationIssue[] = [];
    const abortEarly = options?.abortEarly ?? false;
    if (!(typeof value === "object" && value !== null && !Array.isArray(value))) {
        _invalidType(issues, [], "object", value);
        if (abortEarly)
            return { success: false, issues };
    }
    else {
        if (!("type" in value)) {
            _missingKey(issues, [], "type");
            if (abortEarly)
                return { success: false, issues };
        }
        if (!("content" in value)) {
            _missingKey(issues, [], "content");
            if (abortEarly)
                return { success: false, issues };
        }
        if ("type" in value) {
            if (value.type !== "text") {
                _invalidValue(issues, ["type"], "\"text\"", JSON.stringify(value.type));
                if (abortEarly)
                    return { success: false, issues };
            }
        }
        if ("content" in value) {
            if (!(typeof value.content === "string")) {
                _invalidType(issues, ["content"], "string", value.content);
                if (abortEarly)
                    return { success: false, issues };
            }
            else {
                if (value.content.length < 1) {
                    _tooSmall(issues, ["content"], "string with length >= 1", `string with length ${value.content.length}`);
                    if (abortEarly)
                        return { success: false, issues };
                }
            }
        }
        for (const key1 in value) {
            if (!["type", "content"].includes(key1)) {
                _unrecognizedKey(issues, [key1], `one of known properties (${["type", "content"].join(", ")})`, key1);
                if (abortEarly)
                    return { success: false, issues };
            }
        }
    }
    if (issues.length > 0) {
        return { success: false, issues };
    }
    return { success: true, data: value as TextItem };
}


function validateImageItem(value: unknown, options?: ValidationOptions): ValidationResult<ImageItem> {
    const issues: ValidationIssue[] = [];
    const abortEarly = options?.abortEarly ?? false;
    if (!(typeof value === "object" && value !== null && !Array.isArray(value))) {
        _invalidType(issues, [], "object", value);
        if (abortEarly)
            return { success: false, issues };
    }
    else {
        if (!("type" in value)) {
            _missingKey(issues, [], "type");
            if (abortEarly)
                return { success: false, issues };
        }
        if (!("url" in value)) {
            _missingKey(issues, [], "url");
            if (abortEarly)
                return { success: false, issues };
        }
        if ("type" in value) {
            if (value.type !== "image") {
                _invalidValue(issues, ["type"], "\"image\"", JSON.stringify(value.type));
                if (abortEarly)
                    return { success: false, issues };
            }
        }
        if ("url" in value) {
            if (!(typeof value.url === "string")) {
                _invalidType(issues, ["url"], "string", value.url);
                if (abortEarly)
                    return { success: false, issues };
            }
            else {
                if (!/^https?:\/\//.test(value.url)) {
                    _invalidString(issues, ["url"], "string matching pattern /^https?:///", value.url);
                    if (abortEarly)
                        return { success: false, issues };
                }
            }
        }
        if ("alt" in value) {
            if (!(typeof value.alt === "string")) {
                _invalidType(issues, ["alt"], "string", value.alt);
                if (abortEarly)
                    return { success: false, issues };
            }
        }
        for (const key1 in value) {
            if (!["type", "url", "alt"].includes(key1)) {
                _unrecognizedKey(issues, [key1], `one of known properties (${["type", "url", "alt"].join(", ")})`, key1);
                if (abortEarly)
                    return { success: false, issues };
            }
        }
    }
    if (issues.length > 0) {
        return { success: false, issues };
    }
    return { success: true, data: value as ImageItem };
}


function validateLinkItem(value: unknown, options?: ValidationOptions): ValidationResult<LinkItem> {
    const issues: ValidationIssue[] = [];
    const abortEarly = options?.abortEarly ?? false;
    if (!(typeof value === "object" && value !== null && !Array.isArray(value))) {
        _invalidType(issues, [], "object", value);
        if (abortEarly)
            return { success: false, issues };
    }
    else {
        if (!("type" in value)) {
            _missingKey(issues, [], "type");
            if (abortEarly)
                return { success: false, issues };
        }
        if (!("href" in value)) {
            _missingKey(issues, [], "href");
            if (abortEarly)
                return { success: false, issues };
        }
        if (!("label" in value)) {
            _missingKey(issues, [], "label");
            if (abortEarly)
                return { success: false, issues };
        }
        if ("type" in value) {
            if (value.type !== "link") {
                _invalidValue(issues, ["type"], "\"link\"", JSON.stringify(value.type));
                if (abortEarly)
                    return { success: false, issues };
            }
        }
        if ("href" in value) {
            if (!(typeof value.href === "string")) {
                _invalidType(issues, ["href"], "string", value.href);
                if (abortEarly)
                    return { success: false, issues };
            }
            else {
                if (!/^https?:\/\//.test(value.href)) {
                    _invalidString(issues, ["href"], "string matching pattern /^https?:///", value.href);
                    if (abortEarly)
                        return { success: false, issues };
                }
            }
        }
        if ("label" in value) {
            if (!(typeof value.label === "string")) {
                _invalidType(issues, ["label"], "string", value.label);
                if (abortEarly)
                    return { success: false, issues };
            }
            else {
                if (value.label.length < 1) {
                    _tooSmall(issues, ["label"], "string with length >= 1", `string with length ${value.label.length}`);
                    if (abortEarly)
                        return { success: false, issues };
                }
            }
        }
        for (const key1 in value) {
            if (!["type", "href", "label"].includes(key1)) {
                _unrecognizedKey(issues, [key1], `one of known properties (${["type", "href", "label"].join(", ")})`, key1);
                if (abortEarly)
                    return { success: false, issues };
            }
        }
    }
    if (issues.length > 0) {
        return { success: false, issues };
    }
    return { success: true, data: value as LinkItem };
}


export function validateNestedAnyOf(value: unknown, options?: ValidationOptions): ValidationResult<NestedAnyOf> {
    const issues: ValidationIssue[] = [];
    const abortEarly = options?.abortEarly ?? false;
    if (!(typeof value === "object" && value !== null && !Array.isArray(value))) {
        _invalidType(issues, [], "object", value);
        if (abortEarly)
            return { success: false, issues };
    }
    else {
        if (!("value" in value)) {
            _missingKey(issues, [], "value");
            if (abortEarly)
                return { success: false, issues };
        }
        if ("value" in value) {
            let _anyOfMatched1 = false;
            if (!_anyOfMatched1 && (() => {
                const _tempIssues: ValidationIssue[] = [];
                if (!(typeof value.value === "object" && value.value !== null && !Array.isArray(value.value))) {
                    _invalidType(_tempIssues, ["value"], "object", value.value);
                    if (abortEarly)
                        return { success: false, _tempIssues };
                }
                else {
                    if (!("kind" in value.value)) {
                        _missingKey(_tempIssues, ["value"], "kind");
                        if (abortEarly)
                            return { success: false, _tempIssues };
                    }
                    if (!("data" in value.value)) {
                        _missingKey(_tempIssues, ["value"], "data");
                        if (abortEarly)
                            return { success: false, _tempIssues };
                    }
                    if ("kind" in value.value) {
                        if (value.value.kind !== "simple") {
                            _invalidValue(_tempIssues, ["value", "kind"], "\"simple\"", JSON.stringify(value.value.kind));
                            if (abortEarly)
                                return { success: false, _tempIssues };
                        }
                    }
                    if ("data" in value.value) {
                        if (!(typeof value.value.data === "string")) {
                            _invalidType(_tempIssues, ["value", "data"], "string", value.value.data);
                            if (abortEarly)
                                return { success: false, _tempIssues };
                        }
                    }
                    for (const key2 in value.value) {
                        if (!["kind", "data"].includes(key2)) {
                            _unrecognizedKey(_tempIssues, ["value", key2], `one of known properties (${["kind", "data"].join(", ")})`, key2);
                            if (abortEarly)
                                return { success: false, _tempIssues };
                        }
                    }
                }
                return _tempIssues.length === 0;
            })()) {
                _anyOfMatched1 = true;
            }
            if (!_anyOfMatched1 && (() => {
                const _tempIssues: ValidationIssue[] = [];
                if (!(typeof value.value === "object" && value.value !== null && !Array.isArray(value.value))) {
                    _invalidType(_tempIssues, ["value"], "object", value.value);
                    if (abortEarly)
                        return { success: false, _tempIssues };
                }
                else {
                    if (!("kind" in value.value)) {
                        _missingKey(_tempIssues, ["value"], "kind");
                        if (abortEarly)
                            return { success: false, _tempIssues };
                    }
                    if (!("nested" in value.value)) {
                        _missingKey(_tempIssues, ["value"], "nested");
                        if (abortEarly)
                            return { success: false, _tempIssues };
                    }
                    if ("kind" in value.value) {
                        if (value.value.kind !== "complex") {
                            _invalidValue(_tempIssues, ["value", "kind"], "\"complex\"", JSON.stringify(value.value.kind));
                            if (abortEarly)
                                return { success: false, _tempIssues };
                        }
                    }
                    if ("nested" in value.value) {
                        const _refResult3 = validateTextItem(value.value.nested, options);
                        if (!_refResult3.success) {
                            for (const _issue4 of _refResult3.issues) {
                                _tempIssues.push({ ..._issue4, path: [...["value", "nested"], ..._issue4.path] });
                            }
                            if (abortEarly)
                                return { success: false, _tempIssues };
                        }
                    }
                    for (const key5 in value.value) {
                        if (!["kind", "nested"].includes(key5)) {
                            _unrecognizedKey(_tempIssues, ["value", key5], `one of known properties (${["kind", "nested"].join(", ")})`, key5);
                            if (abortEarly)
                                return { success: false, _tempIssues };
                        }
                    }
                }
                return _tempIssues.length === 0;
            })()) {
                _anyOfMatched1 = true;
            }
            if (!_anyOfMatched1) {
                issues.push({ code: "invalid_type", path: ["value"], message: `Expected ${"value matching at least one schema"}, received ${"value matching no schemas"}`, expected: "value matching at least one schema", received: "value matching no schemas" });
                if (abortEarly)
                    return { success: false, issues };
            }
        }
        for (const key6 in value) {
            if (!["value"].includes(key6)) {
                _unrecognizedKey(issues, [key6], `one of known properties (${["value"].join(", ")})`, key6);
                if (abortEarly)
                    return { success: false, issues };
            }
        }
    }
    if (issues.length > 0) {
        return { success: false, issues };
    }
    return { success: true, data: value as NestedAnyOf };
}
export function unsafeValidateNestedAnyOf(value: unknown): NestedAnyOf {
    const result = validateNestedAnyOf(value, { abortEarly: true });
    if (!result.success) {
        throw new Error("Validation failed: value is not NestedAnyOf");
    }
    return result.data;
}
